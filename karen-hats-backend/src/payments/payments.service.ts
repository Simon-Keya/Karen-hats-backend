import { Inject, Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import PayPalClient from '@paypal/checkout-server-sdk';
import axios from 'axios';
import Stripe from 'stripe';
import { Order } from '../orders/entity/order.entity'; // Adjust import based on your structure
import { OrdersService } from '../orders/orders.service';

@Injectable()
export class PaymentsService {
  private paypalClient: PayPalClient.core.PayPalHttpClient;
  private stripe: Stripe;

  constructor(
    @Inject(ConfigService) private configService: ConfigService,
    private readonly ordersService: OrdersService,
  ) {
    // Initialize PayPal client
    const environment = new PayPalClient.core.SandboxEnvironment(
      this.configService.get('PAYPAL_CLIENT_ID'),
      this.configService.get('PAYPAL_CLIENT_SECRET'),
    );
    this.paypalClient = new PayPalClient.core.PayPalHttpClient(environment);

    // Initialize Stripe client with a valid API version
    this.stripe = new Stripe(this.configService.get('STRIPE_SECRET_KEY'), {
      apiVersion: '2024-06-20', // Ensure this matches the required type
    });
  }

  async processPayPalPayment(orderId: number, paymentDetails: any) {
    try {
      const order: Order = await this.ordersService.findOne(orderId);

      // Create PayPal order
      const request = new PayPalClient.orders.OrdersCreateRequest();
      request.requestBody({
        intent: 'CAPTURE',
        purchase_units: [{
          amount: {
            currency_code: 'USD',
            value: order.totalAmount.toFixed(2),
          },
        }],
      });

      const response = await this.paypalClient.execute(request);

      // Update order status to "Paid" if successful
      if (response.statusCode === 201) {
        await this.ordersService.updateOrderStatus(orderId, 'Paid');
        return {
          status: 'success',
          message: 'Payment processed successfully',
          paypalOrderId: response.result.id,
        };
      }
    } catch (error) {
      await this.ordersService.updateOrderStatus(orderId, 'Payment Failed');
      return {
        status: 'failed',
        message: 'Payment failed',
        error: error.message,
      };
    }
  }

  async processMpesaPayment(orderId: number, phoneNumber: string, amount: number) {
    try {
      const token = await this.getMpesaToken();
      const response = await axios.post(
        `${this.configService.get('MPESA_API_URL')}/mpesa/stkpush/v1/processrequest`,
        {
          BusinessShortCode: this.configService.get('MPESA_SHORTCODE'),
          Password: this.generateMpesaPassword(),
          Timestamp: this.getTimestamp(),
          TransactionType: 'CustomerPayBillOnline',
          Amount: amount,
          PartyA: phoneNumber,
          PartyB: this.configService.get('MPESA_SHORTCODE'),
          PhoneNumber: phoneNumber,
          CallBackURL: this.configService.get('MPESA_CALLBACK_URL'),
          AccountReference: orderId,
          TransactionDesc: `Payment for Order #${orderId}`,
        },
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        },
      );

      // Handle successful payment
      await this.ordersService.updateOrderStatus(orderId, 'Paid');
      return {
        status: 'success',
        message: 'Payment processed successfully',
        mpesaReceiptNumber: response.data.CheckoutRequestID,
      };
    } catch (error) {
      await this.ordersService.updateOrderStatus(orderId, 'Payment Failed');
      return {
        status: 'failed',
        message: 'Payment failed',
        error: error.message,
      };
    }
  }

  async processStripePayment(orderId: number, token: string) {
    try {
      const order: Order = await this.ordersService.findOne(orderId);

      // Create a charge with Stripe
      const charge = await this.stripe.charges.create({
        amount: Math.round(order.totalAmount * 100), // Amount in cents
        currency: 'usd',
        description: `Payment for Order #${orderId}`,
        source: token, // Token generated by Stripe.js
      });

      // Update order status to "Paid" if successful
      if (charge.status === 'succeeded') {
        await this.ordersService.updateOrderStatus(orderId, 'Paid');
        return {
          status: 'success',
          message: 'Payment processed successfully',
          stripeChargeId: charge.id,
        };
      }
    } catch (error) {
      await this.ordersService.updateOrderStatus(orderId, 'Payment Failed');
      return {
        status: 'failed',
        message: 'Payment failed',
        error: error.message,
      };
    }
  }

  private async getMpesaToken() {
    const response = await axios.get(
      `${this.configService.get('MPESA_API_URL')}/oauth/v1/generate?grant_type=client_credentials`,
      {
        auth: {
          username: this.configService.get('MPESA_CONSUMER_KEY'),
          password: this.configService.get('MPESA_CONSUMER_SECRET'),
        },
      },
    );
    return response.data.access_token;
  }

  private generateMpesaPassword(): string {
    const shortCode = this.configService.get('MPESA_SHORTCODE');
    const passkey = this.configService.get('MPESA_PASSKEY');
    const timestamp = this.getTimestamp();
    const dataToEncode = shortCode + passkey + timestamp;
    return Buffer.from(dataToEncode).toString('base64');
  }

  private getTimestamp(): string {
    const now = new Date();
    return (
      now.getFullYear().toString() +
      ('0' + (now.getMonth() + 1)).slice(-2) +
      ('0' + now.getDate()).slice(-2) +
      ('0' + now.getHours()).slice(-2) +
      ('0' + now.getMinutes()).slice(-2) +
      ('0' + now.getSeconds()).slice(-2)
    );
  }
}
